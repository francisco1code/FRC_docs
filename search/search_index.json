{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Fundamento de Redes de Computadores","text":""},{"location":"#professor","title":"Professor:","text":"<p>Fernando William Cruz</p>"},{"location":"#autores","title":"Autores:","text":"<p>Francisco Emanoel Ferreira da Penha- 170142329</p> <p>Leonardo da Silva Gomes - 180021974 </p> <p>Paulo Gon\u00e7alves Lima - 170122549</p> <p>Pedro V\u00edtor de Salles Cella - 170113060</p>"},{"location":"cripto/","title":"Laborat\u00f3rio sobre criptografia sim\u00e9trica e assim\u00e9trica","text":""},{"location":"cripto/#fractal","title":"Fractal","text":""},{"location":"cripto/#observacoes","title":"Observa\u00e7\u00f5es","text":""},{"location":"cripto/#1-compile-usando","title":"1 - Compile usando","text":"<pre><code>gcc fractal.c -o fractal.bin -lm\n</code></pre>"},{"location":"cripto/#2-rode-o-programa-com","title":"2 - Rode o programa com","text":"<pre><code>./fractal.bin 153\n</code></pre> <p>Para que seja criado um fractal para poder ser utilizado durante as partes do projeto DES e RSA.</p>"},{"location":"cripto/#des","title":"DES","text":"<p>Criptografia sim\u00e9trica, utilizamos uma PSK para poder fazer a encripta\u00e7\u00e3o do fractal gerado.</p> <p>Utilizamos uma conex\u00e3o TCP/IP para que seja poss\u00edvel fazer a transfer\u00eancia do arquivo encriptado.</p> <p>Aqui est\u00e1 uma vis\u00e3o geral simplificada do processo de encripta\u00e7\u00e3o DES:</p> <ol> <li> <p>Chave de 56 bits: O algoritmo utiliza uma chave de 56 bits para a encripta\u00e7\u00e3o. Os outros 8 bits s\u00e3o usados como paridade e n\u00e3o t\u00eam efeito na encripta\u00e7\u00e3o em si.</p> </li> <li> <p>Gera\u00e7\u00e3o das sub chaves: A chave de 56 bits \u00e9 transformada em 16 subchaves de 48 bits cada uma. Essas subchaves s\u00e3o geradas por meio de permuta\u00e7\u00f5es e deslocamentos.</p> </li> <li> <p>Divis\u00e3o em blocos: A mensagem de entrada \u00e9 dividida em blocos de 64 bits.</p> </li> <li> <p>Inicializa\u00e7\u00e3o: Cada bloco \u00e9 permutado inicialmente antes de ser processado pelas rodadas.</p> </li> <li> <p>Rodadas (Feistel Network): O bloco de 64 bits \u00e9 processado em uma s\u00e9rie de 16 rodadas id\u00eanticas. Cada rodada aplica uma fun\u00e7\u00e3o complexa que envolve substitui\u00e7\u00f5es, permuta\u00e7\u00f5es e opera\u00e7\u00f5es l\u00f3gicas com as subchaves geradas anteriormente.</p> </li> <li> <p>Permuta\u00e7\u00e3o final: Ap\u00f3s todas as rodadas, \u00e9 aplicada uma \u00faltima permuta\u00e7\u00e3o para reorganizar os bits finais do bloco.</p> </li> <li> <p>Bloco encriptado: O resultado final da encripta\u00e7\u00e3o \u00e9 um bloco de 64 bits transformado.</p> </li> </ol>"},{"location":"cripto/#observacoes_1","title":"Observa\u00e7\u00f5es","text":"<p>Verifique se tem um arquivo fractaljulia.bmp na raiz do projeto.</p>"},{"location":"cripto/#1-compile-usando_1","title":"1 - Compile usando","text":"<pre><code>1. gcc server.c des.c -O3 -o server.bin -lm -lcrypto \n2. gcc client.c des.c -O3 -o client.bin -lm -lcrypto\n</code></pre>"},{"location":"cripto/#instrucoes-de-uso","title":"Instru\u00e7\u00f5es de Uso","text":""},{"location":"cripto/#configuracoes","title":"Configura\u00e7\u00f5es","text":"<p>Para poder definir em qual porta o servidor vai rodar.</p>"},{"location":"cripto/#serverc","title":"server.c","text":""},{"location":"cripto/#clientc","title":"client.c","text":"<p>Configura\u00e7\u00f5es para poder dizer onde que o servidor est\u00e1 rodando.</p>"},{"location":"cripto/#1-inicie-o-servidor","title":"1 - Inicie o servidor","text":"<p>Para que seja poss\u00edvel o cliente fazer a troca de arquivos e chaves.</p> <pre><code>    ./server.bin\n</code></pre>"},{"location":"cripto/#2-inicie-o-cliente","title":"2 - Inicie o cliente","text":"<pre><code>    ./client.bin ../fractaljulia.bmp\n</code></pre>"},{"location":"cripto/#rsa","title":"RSA","text":"<p>Vamos explicar as etapas do algoritmo RSA de forma mais detalhada:</p> <ol> <li> <p>Sele\u00e7\u00e3o de n\u00fameros primos: O algoritmo come\u00e7a selecionando dois n\u00fameros primos grandes, geralmente com cerca de 1024 bits cada, chamados de p e q. A escolha de n\u00fameros primos \u00e9 fundamental para a seguran\u00e7a do algoritmo, pois a fatora\u00e7\u00e3o de n\u00fameros compostos em seus fatores primos \u00e9 uma tarefa computacionalmente dif\u00edcil.</p> </li> <li> <p>C\u00e1lculo de n e z: Com os n\u00fameros primos p e q selecionados, calcula-se o produto n = p * q, que ser\u00e1 utilizado na constru\u00e7\u00e3o das chaves. Tamb\u00e9m \u00e9 calculado o valor z = (p - 1) * (q - 1), que ser\u00e1 utilizado na etapa seguinte.</p> </li> <li> <p>Escolha de e: Em seguida, \u00e9 escolhido um n\u00famero \u00e9, menor que n, que n\u00e3o tenha fatores em comum com z. N\u00fameros que n\u00e3o compartilham fatores primos com z s\u00e3o chamados de \"primos entre si\". O valor de e \u00e9 utilizado para formar a chave p\u00fablica.</p> </li> <li> <p>C\u00e1lculo de d: Ap\u00f3s a escolha de e, \u00e9 calculado o valor de d de forma que a multiplica\u00e7\u00e3o de e por d menos 1 seja divis\u00edvel por z, ou seja, e * d mod z = 1. A exist\u00eancia de d \u00e9 garantida pelo Teorema de Euler. O valor de d \u00e9 utilizado para formar a chave privada.</p> </li> <li> <p>Chaves p\u00fablica e privada: Finalmente, as chaves s\u00e3o formadas. A chave p\u00fablica consiste no par (n, e), e \u00e9 utilizada para criptografar dados. A chave privada \u00e9 formada pelo par (n, d) e \u00e9 utilizada para descriptografar os dados criptografados com a chave p\u00fablica. A distribui\u00e7\u00e3o segura das chaves \u00e9 essencial para garantir a seguran\u00e7a do sistema, j\u00e1 que a chave privada n\u00e3o deve ser compartilhada e apenas o detentor da chave privada pode realizar a descriptografia. Com esse conjunto de chaves, o algoritmo RSA oferece uma criptografia segura e amplamente utilizada em comunica\u00e7\u00f5es modernas.</p> </li> </ol>"},{"location":"cripto/#tentativas","title":"Tentativas","text":"<p>Primeiro tentamos criar a encripta\u00e7\u00e3o fazendo os c\u00e1lculos de cada vari\u00e1vel necess\u00e1ria sendo elas P, Q, Z, N, E e D.</p>"},{"location":"cripto/#calculo-p-e-q","title":"C\u00e1lculo P e Q","text":""},{"location":"cripto/#calculo-z","title":"C\u00e1lculo Z","text":""},{"location":"cripto/#calculo-e","title":"C\u00e1lculo E","text":""},{"location":"cripto/#calculo-d","title":"C\u00e1lculo D","text":"<p>Mas como os n\u00fameros primos que est\u00e1vamos utilizando tinham entre 5 e 6 d\u00edgitos, o D que era necess\u00e1rio para poder encriptar a mensagem ficava muito grande para poder ser computado pelas nossas m\u00e1quinas. Por isso acabamos fazendo uma segunda vers\u00e3o utilizando a biblioteca do OpenSSL.</p>"},{"location":"cripto/#observacoes_2","title":"Observa\u00e7\u00f5es","text":"<p>Garanta que est\u00e1 instalado a biblioteca OpenSSL.</p> <pre><code>sudo apt-get install libssl-dev\n</code></pre>"},{"location":"cripto/#ordem-de-execucao","title":"Ordem de execu\u00e7\u00e3o","text":"<pre><code># Para poder gerar os n\u00fameros primos\n1. gcc gerarsa.c -lssl -lcrypto -o gerarsa.bin -O3 &amp;&amp; ./gerarsa.bin -p\n\n# Para poder gerar a chave .pub e .priv utilizando os primos gerados.\n2. gcc gerarsa.c -lssl -lcrypto -o gerarsa.bin -O3 &amp;&amp; ./gerarsa.bin -k ./primos.txt\n\n# Inicia o programa para iniciar a comunica\u00e7\u00e3o com o cliente.\n3. gcc rsa_decrypt.c -lssl -lcrypto -o decrypt.bin -O3 &amp;&amp; ./decrypt.bin\n\n# Inicia o programa para iniciar a comunica\u00e7\u00e3o com o servidor.\n4. gcc rsa_encrypt.c -lssl -lcrypto -o encrypt.bin -O3 &amp;&amp; ./encrypt.bin ../fractaljulia.bmp\n</code></pre>"},{"location":"critpto-relatorio/","title":"Introdu\u00e7\u00e3o","text":"<p>A criptografia \u00e9 uma das \u00e1reas fundamentais da seguran\u00e7a da informa\u00e7\u00e3o, desempenhando um papel crucial na prote\u00e7\u00e3o de dados sens\u00edveis e na garantia da privacidade em ambientes digitais. Nesse contexto, o presente relat\u00f3rio apresenta uma explora\u00e7\u00e3o aprofundada dos conceitos e t\u00e9cnicas relacionadas \u00e0 criptografia sim\u00e9trica e assim\u00e9trica, atrav\u00e9s da realiza\u00e7\u00e3o de atividades pr\u00e1ticas em laborat\u00f3rio.</p> <p>O objetivo principal desta pesquisa \u00e9 proporcionar uma oportunidade \u00fanica de ampliar os conhecimentos na \u00e1rea de criptografia, por meio de experi\u00eancias pr\u00e1ticas envolvendo dois dos mais renomados algoritmos criptogr\u00e1ficos: DES (Data Encryption Standard) e RSA (Rivest-Shamir-Adleman).</p> <p>O relat\u00f3rio descreve de forma breve o funcionamento  do algoritmo abordado em quest\u00e3o e a solu\u00e7\u00e3o realizada, assim como uma breve descri\u00e7\u00e3o das dificuldades enfrentadas.</p>"},{"location":"critpto-relatorio/#criptografia-simetrica","title":"Criptografia Sim\u00e9trica","text":"<p>A criptografia sim\u00e9trica \u00e9 uma t\u00e9cnica em que o mesmo segredo ou chave \u00e9 utilizado tanto para criptografar quanto para descriptografar a mensagem. Nesse processo, tanto o remetente quanto o destinat\u00e1rio precisam compartilhar previamente a chave secreta, tornando a seguran\u00e7a do sistema dependente da prote\u00e7\u00e3o dessa chave. O algoritmo de DES (Data Encryption Standard) \u00e9 um dos exemplos mais not\u00e1veis de criptografia sim\u00e9trica. Desenvolvido na d\u00e9cada de 1970, o DES utiliza uma chave de 56 bits para cifrar blocos de dados de 64 bits, aplicando uma s\u00e9rie de transforma\u00e7\u00f5es como permuta\u00e7\u00f5es e substitui\u00e7\u00f5es para garantir a confidencialidade dos dados. </p>"},{"location":"critpto-relatorio/#uma-breve-descricao-de-cada-codigo","title":"Uma breve descri\u00e7\u00e3o de cada c\u00f3digo:","text":""},{"location":"critpto-relatorio/#desc","title":"des.c:","text":"<p>O c\u00f3digo cont\u00e9m diversas estruturas de dados, constantes e fun\u00e7\u00f5es relacionadas \u00e0 criptografia DES, incluindo a permuta\u00e7\u00e3o inicial da chave e da mensagem, as tabelas de substitui\u00e7\u00e3o S-Box utilizadas durante o processo de criptografia, a gera\u00e7\u00e3o das subchaves a partir da chave principal e a aplica\u00e7\u00e3o das etapas de criptografia e descriptografia em um bloco de dados de 64 bits.</p> <p>Para criptografar uma mensagem, o c\u00f3digo recebe uma chave e um bloco de dados e, a partir da chave, gera um conjunto de 16 subchaves para serem utilizadas nas rodadas do algoritmo. O bloco de dados passa por um processo de permuta\u00e7\u00e3o inicial e, em seguida, \u00e9 dividido em metades esquerda e direita. As rodadas de criptografia (16 no total) s\u00e3o executadas alternando as metades do bloco e aplicando diversas opera\u00e7\u00f5es de substitui\u00e7\u00e3o e permuta\u00e7\u00e3o utilizando as subchaves geradas. O resultado \u00e9 um bloco de dados criptografado.</p>"},{"location":"critpto-relatorio/#serverc","title":"server.c:","text":"<p>O c\u00f3digo \u00e9 um programa C que implementa um servidor de transfer\u00eancia de arquivos BMP criptografados usando o algoritmo de criptografia DES (Data Encryption Standard). Um resumo do seu passo a passo:</p> <ol> <li> <p>Bibliotecas e constantes: O c\u00f3digo inclui v\u00e1rias bibliotecas necess\u00e1rias para executar fun\u00e7\u00f5es de criptografia DES, manipula\u00e7\u00e3o de arquivos e sockets de rede. Tamb\u00e9m define constantes como a porta do servidor e o tamanho da chave DES.</p> </li> <li> <p>Decifra\u00e7\u00e3o (fun\u00e7\u00e3o \"decrypt\"): A fun\u00e7\u00e3o \"decrypt\" \u00e9 respons\u00e1vel por decifrar o arquivo BMP criptografado usando a chave DES fornecida. O arquivo criptografado \u00e9 lido, e blocos de dados de 8 bytes s\u00e3o processados usando a chave DES para descriptograf\u00e1-los. O arquivo descriptografado \u00e9 ent\u00e3o salvo em um novo arquivo chamado \"julia_decripted.bmp\".</p> </li> <li> <p>Recebendo a chave do cliente (fun\u00e7\u00e3o \"recive_key\"): Quando o cliente se conecta ao servidor, ele envia a chave de criptografia DES de 8 bytes para o servidor. Essa chave \u00e9 recebida pela fun\u00e7\u00e3o \"recive_key\" no servidor.</p> </li> <li> <p>Recebendo e descriptografando o arquivo BMP (fun\u00e7\u00e3o \"receive_bmp_over_tcp\"): A fun\u00e7\u00e3o \"receive_bmp_over_tcp\" \u00e9 respons\u00e1vel por receber os dados do arquivo BMP criptografado do cliente e salv\u00e1-los em um arquivo chamado \"encrypted_file.ecry\". Em seguida, ele chama a fun\u00e7\u00e3o \"decrypt\" para descriptografar o arquivo salvo.</p> </li> <li> <p>Configurando o servidor: O programa principal come\u00e7a criando um socket TCP e o associa a uma porta especificada (SERVER_PORT) para aguardar conex\u00f5es de clientes.</p> </li> <li> <p>Aceitando conex\u00f5es: O servidor fica em modo de escuta e aguarda a conex\u00e3o de um cliente. Quando um cliente se conecta, o servidor aceita a conex\u00e3o e obt\u00e9m o descritor do socket do cliente (client_fd).</p> </li> <li> <p>Processo de recebimento: O servidor recebe a chave criptogr\u00e1fica do cliente e, em seguida, invoca a fun\u00e7\u00e3o \"receive_bmp_over_tcp\" para receber o arquivo BMP criptografado, salvar em \"encrypted_file.ecry\" e, finalmente, descriptograf\u00e1-lo chamando a fun\u00e7\u00e3o \"decrypt\".</p> </li> <li> <p>Finalizando: Depois que o arquivo \u00e9 descriptografado e salvo como \"julia_decripted.bmp\", o servidor fecha os sockets de cliente e servidor e encerra a execu\u00e7\u00e3o.</p> </li> </ol> <p>O c\u00f3digo permite que um cliente envie um arquivo BMP criptografado usando DES para o servidor, que por sua vez descriptografa o arquivo e o salva no servidor com o nome \"julia_decripted.bmp\". Note que este c\u00f3digo parece ser parte de um sistema maior, possivelmente envolvendo um cliente que criptografa os arquivos antes de enviar ao servidor para descriptografia.</p>"},{"location":"critpto-relatorio/#clientc","title":"client.c:","text":"<p>O c\u00f3digo \u00e9 um programa C que implementa um cliente de transfer\u00eancia de arquivos BMP criptografados usando o algoritmo de criptografia DES (Data Encryption Standard). Um resumo do seu passo a passo:</p> <ol> <li>Bibliotecas e constantes: O c\u00f3digo inclui v\u00e1rias bibliotecas necess\u00e1rias para executar fun\u00e7\u00f5es de criptografia DES, manipula\u00e7\u00e3o de arquivos e sockets de rede. Tamb\u00e9m define constantes como o endere\u00e7o IP e a porta do servidor.</li> <li> <p>Gera\u00e7\u00e3o da chave (fun\u00e7\u00e3o \"gen_key\"): A fun\u00e7\u00e3o \"gen_key\" \u00e9 respons\u00e1vel por gerar uma chave de criptografia DES de 8 bytes.</p> </li> <li> <p>Criptografia (fun\u00e7\u00e3o \"encrypt\"): A fun\u00e7\u00e3o \"encrypt\" \u00e9 respons\u00e1vel por criptografar um arquivo BMP usando a chave DES gerada pela fun\u00e7\u00e3o \"gen_key\". O arquivo BMP \u00e9 lido e dividido em blocos de 8 bytes, que s\u00e3o processados usando a chave DES para criptograf\u00e1-los. O arquivo criptografado \u00e9 salvo em um novo arquivo chamado \"julia_encrypted\".</p> </li> <li> <p>Enviando a chave e o arquivo criptografado para o servidor: O cliente cria um socket TCP e tenta se conectar ao servidor usando o endere\u00e7o IP e a porta fornecidos.  Ap\u00f3s a conex\u00e3o bem-sucedida, o cliente envia a chave DES gerada pelo servidor para criptografar o arquivo BMP. Em seguida, ele chama a fun\u00e7\u00e3o \"send_over_tcp_encrypted_bmp\" para enviar o arquivo criptografado para o servidor.</p> </li> <li> <p>Lendo o arquivo criptografado e enviando para o servidor: A fun\u00e7\u00e3o \"send_over_tcp_encrypted_bmp\" abre o arquivo criptografado gerado pela fun\u00e7\u00e3o \"encrypt\" e l\u00ea seu conte\u00fado para um buffer. Em seguida, o cliente envia o conte\u00fado do arquivo criptografado para o servidor atrav\u00e9s da conex\u00e3o TCP.</p> </li> <li> <p>Finalizando: Ap\u00f3s o envio bem-sucedido do arquivo criptografado, o cliente fecha o socket e encerra a execu\u00e7\u00e3o.</p> </li> </ol>"},{"location":"critpto-relatorio/#forma-de-uso","title":"Forma de uso:","text":"<p>1- Compile o fractal:     gcc fractal.c -o fractal -lm</p> <p>2- Compile e rode usando:</p> <p><code>gcc server.c des.c -O3 -o server.bin -lm -lcrypto &amp;&amp; ./server.bin</code></p> <p><code>gcc client.c des.c -O3 -o client.bin -lm -lcrypto &amp;&amp; ./client.bin ../fractaljulia.bmp</code></p>"},{"location":"critpto-relatorio/#criptografia-assimetrica","title":"Criptografia Assim\u00e9trica","text":"<p>A criptografia assim\u00e9trica \u00e9 um m\u00e9todo criptogr\u00e1fico que utiliza um par de chaves relacionadas matematicamente: uma chave p\u00fablica e uma chave privada. A chave p\u00fablica \u00e9 usada para criptografar dados, enquanto a chave privada \u00e9 usada para descriptograf\u00e1-los. O importante \u00e9 que a chave p\u00fablica pode ser compartilhada amplamente, permitindo que qualquer pessoa criptografe informa\u00e7\u00f5es para o propriet\u00e1rio da chave privada, mas apenas o propriet\u00e1rio da chave privada \u00e9 capaz de descriptografar os dados. Isso torna a criptografia assim\u00e9trica ideal para garantir a seguran\u00e7a de comunica\u00e7\u00f5es na internet, como a troca segura de chaves em protocolos de seguran\u00e7a, autentica\u00e7\u00e3o e assinatura digital.</p> <p>O algoritmo RSA \u00e9 um dos algoritmos mais populares de criptografia assim\u00e9trica. Foi proposto em 1977 por Ron Rivest, Adi Shamir e Leonard Adleman, da\u00ed o nome RSA. O algoritmo \u00e9 baseado em opera\u00e7\u00f5es matem\u00e1ticas com n\u00fameros primos grandes. O processo envolve a gera\u00e7\u00e3o de dois n\u00fameros primos, a cria\u00e7\u00e3o das chaves p\u00fablica e privada a partir desses primos e a aplica\u00e7\u00e3o de f\u00f3rmulas matem\u00e1ticas para criptografar e descriptografar os dados</p> <p>Vamos explicar as etapas do algoritmo RSA de forma mais detalhada:</p> <ol> <li> <p>Sele\u00e7\u00e3o de n\u00fameros primos: O algoritmo come\u00e7a selecionando dois n\u00fameros primos grandes, geralmente com cerca de 1024 bits cada, chamados de p e q. A escolha de n\u00fameros primos \u00e9 fundamental para a seguran\u00e7a do algoritmo, pois a fatora\u00e7\u00e3o de n\u00fameros compostos em seus fatores primos \u00e9 uma tarefa computacionalmente dif\u00edcil.</p> </li> <li> <p>C\u00e1lculo de n e z: Com os n\u00fameros primos p e q selecionados, calcula-se o produto n = p * q, que ser\u00e1 utilizado na constru\u00e7\u00e3o das chaves. Tamb\u00e9m \u00e9 calculado o valor z = (p - 1) * (q - 1), que ser\u00e1 utilizado na etapa seguinte.</p> </li> <li> <p>Escolha de e: Em seguida, \u00e9 escolhido um n\u00famero e, menor que n, que n\u00e3o tenha fatores em comum com z. N\u00fameros que n\u00e3o compartilham fatores primos com z s\u00e3o chamados de \"primos entre si\". O valor de e \u00e9 utilizado para formar a chave p\u00fablica.</p> </li> <li> <p>C\u00e1lculo de d: Ap\u00f3s a escolha de e, \u00e9 calculado o valor de d de forma que a multiplica\u00e7\u00e3o de e por d menos 1 seja divis\u00edvel por z, ou seja, e * d mod z = 1. A exist\u00eancia de d \u00e9 garantida pelo Teorema de Euler. O valor de d \u00e9 utilizado para formar a chave privada.</p> </li> <li> <p>Chaves p\u00fablica e privada: Finalmente, as chaves s\u00e3o formadas. A chave p\u00fablica consiste no par (n, e), e \u00e9 utilizada para criptografar dados. A chave privada \u00e9 formada pelo par (n, d) e \u00e9 utilizada para descriptografar os dados criptografados com a chave p\u00fablica. A distribui\u00e7\u00e3o segura das chaves \u00e9 essencial para garantir a seguran\u00e7a do sistema, j\u00e1 que a chave privada n\u00e3o deve ser compartilhada e apenas o detentor da chave privada pode realizar a descriptografia. Com esse conjunto de chaves, o algoritmo RSA oferece uma criptografia segura e amplamente utilizada em comunica\u00e7\u00f5es modernas.</p> <p>Vamos explicar as etapas do processo de criptografia e descriptografia usando as chaves geradas pelo algoritmo RSA:</p> </li> </ol> <p>Cifragem (criptografia): Para cifrar uma mensagem m usando a chave p\u00fablica (n, e), o remetente computa o criptograma c utilizando a f\u00f3rmula c = (m^e) mod n, ou seja, o resto da divis\u00e3o da mensagem m elevada \u00e0 pot\u00eancia de e por n. Neste processo, a mensagem original \u00e9 convertida em uma sequ\u00eancia de n\u00fameros que representam o criptograma cifrado. Esse criptograma c pode ser transmitido de forma segura, pois somente o detentor da chave privada correspondente ser\u00e1 capaz de descriptografar a mensagem. Decifragem (descriptografia): Para decifrar o criptograma c e obter a mensagem original m, o destinat\u00e1rio utiliza a chave privada (n, d). A descriptografia \u00e9 realizada computando m = (c^d) mod n, ou seja, o resto da divis\u00e3o do criptograma c elevado \u00e0 pot\u00eancia de d por n. Essa opera\u00e7\u00e3o recupera a mensagem original a partir do criptograma e permite ao destinat\u00e1rio ler a informa\u00e7\u00e3o original enviada pelo remetente. \u00c9 importante notar que a descriptografia s\u00f3 \u00e9 poss\u00edvel com o uso da chave privada correspondente \u00e0 chave p\u00fablica usada para cifrar a mensagem.</p>"},{"location":"critpto-relatorio/#forma-de-uso_1","title":"Forma de uso:","text":"<p>1- Compile o fractal:     gcc fractal.c -o fractal -lm</p>"},{"location":"critpto-relatorio/#conclusao","title":"Conclus\u00e3o","text":"<p>Em conclus\u00e3o, este relat\u00f3rio apresentou uma abordagem abrangente sobre dois importantes paradigmas de criptografia: a sim\u00e9trica e a assim\u00e9trica, destacando os algoritmos RSA e DES como exemplos representativos de cada tipo. A criptografia sim\u00e9trica, com a utiliza\u00e7\u00e3o de uma \u00fanica chave para cifragem e descriptografia, destaca-se por sua efici\u00eancia e velocidade, mas enfrenta o desafio de compartilhar a chave de forma segura entre as partes envolvidas. Por outro lado, a criptografia assim\u00e9trica, com seu par de chaves p\u00fablica e privada, oferece uma solu\u00e7\u00e3o elegante para a troca segura de informa\u00e7\u00f5es, mas pode ser mais lenta em opera\u00e7\u00f5es criptogr\u00e1ficas intensivas. A compreens\u00e3o desses m\u00e9todos e suas respectivas aplica\u00e7\u00f5es \u00e9 essencial para a constru\u00e7\u00e3o de sistemas de seguran\u00e7a robustos.</p> <p>Al\u00e9m disso, este relat\u00f3rio descreveu a implementa\u00e7\u00e3o de um sistema de envio seguro de fractais atrav\u00e9s de uma conex\u00e3o TCP/IP. A combina\u00e7\u00e3o das t\u00e9cnicas de criptografia RSA e DES assegurou a confidencialidade dos dados durante a transmiss\u00e3o, garantindo que apenas o destinat\u00e1rio autorizado pudesse decifrar o conte\u00fado original. Esse sistema demonstrou a import\u00e2ncia de empregar medidas de seguran\u00e7a adequadas para proteger informa\u00e7\u00f5es sens\u00edveis ao longo de uma rede, especialmente em um contexto onde a seguran\u00e7a dos dados \u00e9 uma prioridade. A utiliza\u00e7\u00e3o eficiente das t\u00e9cnicas de criptografia, aliada a um protocolo de rede seguro como o TCP/IP, refor\u00e7a a capacidade de proteger a integridade e a privacidade das informa\u00e7\u00f5es transmitidas, garantindo a confiabilidade e seguran\u00e7a das comunica\u00e7\u00f5es digitais.</p>"},{"location":"intranet-relatorio/","title":"Introdu\u00e7\u00e3o","text":"<p>No mundo atual, onde a conectividade \u00e9 uma pe\u00e7a fundamental para o funcionamento eficiente de organiza\u00e7\u00f5es, a intranet se destaca como uma poderosa ferramenta que possibilita o compartilhamento seguro e r\u00e1pido de informa\u00e7\u00f5es e servi\u00e7os internos. Nesse contexto, o presente trabalho tem como objetivo a constru\u00e7\u00e3o de uma intranet robusta, baseada no protocolo TCP/IP, visando fornecer aos usu\u00e1rios um ambiente interno eficiente e funcional.</p> <p>A tarefa primordial a ser empreendida nesta atividade \u00e9 a configura\u00e7\u00e3o dos principais servi\u00e7os de uma intranet TCP/IP. O aluno, de forma minuciosa, ter\u00e1 a responsabilidade de implementar e otimizar os servi\u00e7os b\u00e1sicos, incluindo o DNS (Sistema de Nomes de Dom\u00ednios), o SMTP (Protocolo de Transfer\u00eancia de Emails) juntamente com o cliente de e-mail, e a WWW (World Wide Web), a fim de proporcionar uma experi\u00eancia integrada e agrad\u00e1vel aos usu\u00e1rios da intranet.</p>"},{"location":"intranet-relatorio/#dns","title":"DNS","text":"<pre><code>Montagem de rede interconectada para o experimento\n\n1- Certifique-se de ter o Docker e o Docker Compose instalados em seu sistema.\n2- Crie um arquivo chamado docker-compose.yml e adicione o seguinte conte\u00fado:\n</code></pre> <p>version: '3'</p> <p>services:   machine1:     build:       context: .     networks:       mynetwork:         ipv4_address: 192.168.10.1</p> <p>machine2:     build:       context: .     networks:       mynetwork:         ipv4_address: 192.168.10.2</p> <p>networks:   mynetwork:     driver: bridge     ipam:       config:         - subnet: 192.168.10.0/24</p> <p>3- Em paralelo crie um arquivo chamado Dockerfile e adicione o seguinte conte\u00fado: FROM alpine CMD tail -f /dev/null 4- No terminal, navegue at\u00e9 o diret\u00f3rio onde voc\u00ea salvou os arquivos 'docker-compose.yml' e 'Dockerfile'. 5- Execute o comando a seguir para construir as imagens e iniciar os containers: docker-compose up --build -d Aguarde at\u00e9 que os containers sejam criados e iniciados. Eles ser\u00e3o nomeados como nomedopdiret\u00f3rio_machine1_1 e nomedopdiret\u00f3rio_machine2_1 6- Para testar a conectividade entre os containers usando o comando ping, execute os seguintes comandos: docker exec nomedopdiret\u00f3rio_machine1_1 ping 192.168.10.2 docker exec nomedopdiret\u00f3rio_machine2_1 ping 192.168.10.1</p> <p>Os comandos acima executar\u00e3o o ping de um container para o outro usando os endere\u00e7os IP fornecidos. Se a conectividade estiver correta, voc\u00ea receber\u00e1 respostas dos pings e poder\u00e1 confirmar que os containers est\u00e3o se comunicando com sucesso na mesma rede local. OBS: Lembre-se de substituir nomedopdiret\u00f3rio pelo nome do diret\u00f3rio em que voc\u00ea salvou os arquivos docker-compose.yml e Dockerfile.</p>"},{"location":"intranet-relatorio/#configuracao-estatica-local-de-enderecosnomes-atraves-arquivo-hosts","title":"Configura\u00e7\u00e3o est\u00e1tica local de endere\u00e7os/nomes (atrav\u00e9s arquivo hosts)","text":"<p>1- Identifique os nomes que voc\u00ea deseja atribuir \u00e0s m\u00e1quinas da rede montada. Por exemplo, vamos usar os nomes \"machine1\" e \"machine2\". 2- Abra um terminal e execute o seguinte comando para acessar o shell de um dos containers: docker exec -it nomedopdiret\u00f3rio_machine1_1 sh Substitua nomedopdiret\u00f3rio pelo nome do diret\u00f3rio em que voc\u00ea salvou os arquivos do Docker Compose. 3- Dentro do shell do container, edite o arquivo /etc/hosts usando um editor de texto, como o vi: vi /etc/hosts 4- No arquivo /etc/hosts, adicione uma linha para cada nome que voc\u00ea deseja atribuir ao endere\u00e7o IP correspondente. Por exemplo: machine1 127.0.0.1       localhost 192.168.10.1    machine1 192.168.10.2    machine2 &lt;-- Acrescente esse trecho ~</p> <p>machine2 127.0.0.1       localhost 192.168.10.2    machine2 192.168.10.1    machine1 &lt;-- Acrescente esse trecho ~</p>"},{"location":"intranet-relatorio/#varia-de-caso-a-caso-mas-sera-algo-parecido-com-isso","title":"Varia de caso a caso mas ser\u00e1 algo parecido com isso","text":"<p>5- Salve e feche o arquivo. 6- Agora voc\u00ea configurou as associa\u00e7\u00f5es fixas e est\u00e1ticas entre os nomes e os endere\u00e7os IP dentro dos containers. Para testar a resolu\u00e7\u00e3o de nomes local usando o arquivo /etc/hosts, execute o comando ping usando os nomes em vez dos endere\u00e7os IP. Por exemplo: docker exec -it nomedopdiret\u00f3rio_machine1_1 ping machine2 docker exec -it nomedopdiret\u00f3rio_machine2_1 ping machine1 Voc\u00ea deve ver os pacotes de ping sendo enviados e recebidos entre os containers usando os nomes configurados. 7- Para verificar o nome atual do sistema dentro de um container, use o comando hostname: docker exec -it nomedopdiret\u00f3rio_machine1_1 hostname Para alterar o nome do sistema dentro de um container, use o comando hostname seguido pelo novo nome: docker exec -it nomedopdiret\u00f3rio_machine1_1 hostname novo-nome Lembre-se de substituir nomedopdiret\u00f3rio pelo nome do diret\u00f3rio em que voc\u00ea salvou os arquivos do Docker Compose. Caso voc\u00ea receba esse erro: hostname: sethostname: Operation not permitted Basta acrescentar o hostname ao arquivo docker-compose.yml</p> <p>version: '3'</p> <p>services:   machine1:     build:       context: .     networks:       mynetwork:         ipv4_address: 192.168.10.1     hostname: machine1</p> <p>machine2:     build:       context: .     networks:       mynetwork:         ipv4_address: 192.168.10.2     hostname: machine2</p> <p>networks:   mynetwork:     driver: bridge     ipam:       config:         - subnet: 192.168.10.0/24</p> <p>e recriar os cont\u00e2iners com: docker-compose up -d 8- Para verificar o dom\u00ednio configurado no sistema dentro de um container, use o comando dnsdomainname. OBS: O comando dnsdomainname n\u00e3o est\u00e1 dispon\u00edvel dentro dos cont\u00eaineres Docker. No contexto dos cont\u00eaineres, n\u00e3o existe um dom\u00ednio configurado da mesma forma que em um sistema operacional completo. Os cont\u00eaineres Docker s\u00e3o isolados e t\u00eam seu pr\u00f3prio namespace de rede. Eles n\u00e3o est\u00e3o cientes dos dom\u00ednios configurados fora do cont\u00eainer. Portanto, ao executar o comando dnsdomainname dentro de um cont\u00eainer, ele n\u00e3o retornar\u00e1 nada.</p> <p>Configurando o DNS no docker 9- Altere o arquivo resolv.conf: Entre no container criado: docker exec -it dns_machine2_1 /bin/bash/</p> <p>Digite: vi /etc/resolv.conf Dentro do resolv.conf, escreva: nameserver 127.0.0.11 options edns0 trust-ad ndots:0 domain queropassar.com nameserver 192.168.10.2 nameserver 192.168.10.3 10- Altere os arquivos named.conf.local Acesse: cd /etc/bind/ Inicie alterando o arquivo named.conf.local // // Do any local configuration here //</p> <p>// Consider adding the 1918 zones here, if they are not used in your // organization //include \"/etc/bind/zones.rfc1918\"; zone \"queropassar.com\" in {    type master;    file \"/etc/bind/db.queropassar\"; }; / Zona para dns reverso zone \"10.168.192.in-addr.arpa\" in {     type master;     file \"/etc/bind/db.queroreprovar\"; }; Depois crie os arquivos db.dns e db.dnsreverse, com seus respectivos nomes: Primeiro o db.dns: / Cada defini\u00e7\u00e3o de master deve se iniciar com uma entrada SOA / Ela indica o servidor de nomes para o dom\u00ednio em quest\u00e3o e par\u00e2metros de opera\u00e7\u00e3o @ IN SOA flpp.queropassar.com. root.flpp.queropassar.com. ( 2022092601 ;numero serial - deve ser incrementado a cada mudan\u00e7a neste arquivo 21600 ;refresh - das informa\ufffd\ufffd\u00f5es para slaves 1800 ;retry \ufffd~@~S tempo entre as tentativas 604800 ;expire - tempo para se desistir de contactar master 86400 ) ;m\u00ed nimo - tempo a manter a informa\u00e7\u00e3o no cache (TTL) IN NS flpp.queropassar.com. queropassar.com. IN MX 10 FERNANDO.queropassar.com. ;entrada MX (mail server) localhost IN A 127.0.0.1 machine2 IN A 192.168.10.2 machine3 IN A 192.168.10.3 flpp IN A 192.168.10.66 FERNANDO IN A 192.168.10.100 Primeiro o db.dnsreverse: // Realiza a resolu\u00e7\u00e3o reversa // O tipo PTR significa um alias para o endere\u00e7o IP @ IN SOA flpp.queropassar.com. root.flpp.queropassar.com. ( 2022092601 21600 1800 604800 86400 ) IN NS flpp.queropassar.com. 2 IN PTR machine2.queropassar.com. 3 IN PTR machine3.queropassar.com. 66 IN PTR flpp.queropassar.com. 100 IN PTR FERNANDO.queropassar.com. 11- Rode o comando para fazer as mudan\u00e7as realizadas: /etc/init.d/bind9 start ou sudo /usr/sbin/named -f -g -d 1 Esse segundo comando serve para rodar mostrando o que est\u00e1 sendo feito durante o processo. 12- Testando o DNS Rode: nslookup Consulte: server"},{"location":"intranet-relatorio/#smtp","title":"SMTP","text":"<p>Passo 1: Instala\u00e7\u00e3o do Postfix sudo apt install postfix Respostas durante a instala\u00e7\u00e3o: Ok Site da Internet (Internet Site) pv-notebook Passo 2: Configura\u00e7\u00e3o do Postfix Durante a configura\u00e7\u00e3o, responda as seguintes op\u00e7\u00f5es: Ok Site da Internet (Internet Site) pv-notebook NONE chmod.com.br chmod.com.br, pv-notebook, pv-notebook, localhost.localdomain, , localhost_ N\u00e3o 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128_ Limite de tamanho: 0 Caractere de extens\u00e3o: + Todos (all) Passo 3: Iniciando o Postfix sudo service postfix start Passo 4: Adicionando usu\u00e1rios ao grupo adduser francisco adduser leonardo adduser paulo adduser pedro Senha para todos os usu\u00e1rios: redes Passo 5: Instala\u00e7\u00e3o do utilit\u00e1rio de email sudo apt install mailutils Passo 6: Enviando uma mensagem de email Use o comando abaixo substituindo \"nomeuser\" pelo usu\u00e1rio desejado e \"chmod.com.br\" pelo dom\u00ednio correto: mail nomeuser@chmod.com.br Escreva a mensagem e, quando terminar, utilize o comando CTRL + D para encerrar e enviar. Passo 7: Ver mensagens enviadas As mensagens enviadas estar\u00e3o na pasta: /var/mail/</p> <p>Acesse o usu\u00e1rio e veja as mensagens. POP3 e IMAP com Dovecot Passo 1: Instala\u00e7\u00e3o do Dovecot sudo apt install dovecot-core dovecot-imapd dovecot-pop3d Passo 2: Configura\u00e7\u00e3o do Dovecot para aceitar POP3 e IMAP Edite o arquivo de configura\u00e7\u00e3o: sudo nano /etc/dovecot/dovecot.conf Adicione ou descomente as seguintes linhas para aceitar POP3 e IMAP: protocols = imap pop3</p> <p>Realize o restart do Dovecot: sudo systemctl restart dovecot Agora o Dovecot est\u00e1 configurado para suportar ambos os protocolos, POP3 e IMAP. O servidor estar\u00e1 pronto para receber conex\u00f5es dos clientes de email.</p> <p>SMTP com Docker Para fazer a instala\u00e7\u00e3o e configura\u00e7\u00e3o do Postfix usando Docker, voc\u00ea pode seguir os seguintes passos: Passo 1: Acesse o diret\u00f3rio: cd SMTP Passo 2: Crie um arquivo chamado Dockerfile com o seguinte conte\u00fado: // Use a imagem base do Ubuntu (ou outra imagem de sua prefer\u00eancia) FROM ubuntu:latest</p> <p>// Instale o servidor de e-mail Postfix RUN apt-get update &amp;&amp; apt-get install -y postfix</p> <p>// Instale o mail RUN apt install mailutils -y</p> <p>// Copie o arquivo de configura\u00e7\u00e3o pr\u00e9-configurado para dentro do cont\u00eainer COPY postfix-config.txt /etc/postfix/main.cf</p> <p>// Inicie o servi\u00e7o do Postfix quando o cont\u00eainer for iniciado CMD service postfix start &amp;&amp; tail -f /dev/null Passo 3: Crie um arquivo chamado postfix-config.txt com o seguinte conte\u00fado: // Configura\u00e7\u00e3o do Postfix myhostname = chmod.com.br mydestination = chmod.com.br, localhost.localdomain, localhost mynetworks = 127.0.0.0/8, 192.168.10.0/24 inet_interfaces = all</p> <p>Substitua \"chmod.com.br\" pelo nome do seu servidor de e-mail (definido no DNS) e o endere\u00e7o \"192.168.10.0/24\" pelo endere\u00e7o de rede que voc\u00ea definiu para a rede local da sua bancada. Passo 4: Construa a imagem Docker: docker build -t smtp . Passo 5: Execute o container Docker: docker run -d --name smtp -p 2525:25 smtp Agora voc\u00ea tem um servidor de e-mail Postfix em execu\u00e7\u00e3o dentro do cont\u00eainer Docker. Voc\u00ea pode adicionar usu\u00e1rios e enviar e-mails da mesma forma como fez anteriormente: docker exec -it smtp bash</p> <p>// Agora dentro do cont\u00eainer, adicione os usu\u00e1rios adduser francisco adduser leonardo adduser paulo adduser pedro</p> <p>// Enviando os e-mails mail francisco@chmod.com.br mail leonardo@chmod.com.br mail paulo@chmod.com.br mail pedro@chmod.com.br Escreva a mensagem e, quando terminar, utilize o comando CTRL + D para encerrar e enviar. Os e-mails enviados estar\u00e3o dispon\u00edveis nos respectivos arquivos dentro do diret\u00f3rio /var/mail dentro do cont\u00eainer. Para ver os e-mails recebidos, voc\u00ea pode executar: docker exec -it smtp /bin/bash // Agora dentro do cont\u00eainer cat /var/mail/francisco cat /var/mail/gabriela cat /var/mail/murilo cat /var/mail/pedro Lembrando que esse \u00e9 um exemplo b\u00e1sico para executar o Postfix dentro do Docker, e em um ambiente real, voc\u00ea precisaria fazer algumas outras configura\u00e7\u00f5es para garantir a seguran\u00e7a e autentica\u00e7\u00e3o correta dos usu\u00e1rios.</p>"},{"location":"intranet-relatorio/#www","title":"WWW","text":"<pre><code>1 - Instalando o apache no servidor DNS:\n\n    sudo apt install apache2\n</code></pre> <p>2 - Iniciando e testando o apache</p> <p>Foi utilizado o comando sudo service apache2 start para inicializar o programa do apache, depois disso foi criada uma p\u00e1gina html de teste contendo apenas o t\u00edtulo \u201cOl\u00e1 Mundo\u201d em seu conte\u00fado, essa p\u00e1gina foi copiada para o arquivo teste.html dentro da pasta /var/www/html. Ao abrir a p\u00e1gina www.chmod.com.br/index.html foi poss\u00edvel ver a p\u00e1gina descrita. </p> <p>Obs: Ap\u00f3s o teste, o html foi alterado para conter as quest\u00f5es dos experimentos.</p>"},{"location":"intranet-relatorio/#pgp","title":"PGP","text":"<p>O PGP \u00e9 uma tecnologia de criptografia assim\u00e9trica que foi desenvolvida para proteger a privacidade e a autenticidade das comunica\u00e7\u00f5es eletr\u00f4nicas, especialmente e-mails. Foi criado por Phil Zimmermann em 1991 e rapidamente ganhou popularidade por ser uma solu\u00e7\u00e3o eficaz para garantir a seguran\u00e7a das informa\u00e7\u00f5es transmitidas pela internet.</p> <p>A criptografia assim\u00e9trica, tamb\u00e9m conhecida como criptografia de chave p\u00fablica, utiliza um par de chaves: uma chave p\u00fablica e uma chave privada. Cada usu\u00e1rio possui seu pr\u00f3prio par de chaves. A chave p\u00fablica \u00e9 compartilhada com outras pessoas, enquanto a chave privada \u00e9 mantida em segredo e conhecida apenas pelo seu propriet\u00e1rio.</p> <p>Vamos entender como o PGP funciona passo a passo:</p> <p>Gera\u00e7\u00e3o das chaves: O usu\u00e1rio gera seu par de chaves, uma p\u00fablica e uma privada. A chave p\u00fablica \u00e9 usada para criptografar as mensagens e \u00e9 compartilhada livremente com os outros usu\u00e1rios, enquanto a chave privada \u00e9 protegida e armazenada com seguran\u00e7a pelo propriet\u00e1rio.</p> <p>Criptografia de Mensagem: Quando um remetente deseja enviar uma mensagem para um destinat\u00e1rio espec\u00edfico, ele utiliza a chave p\u00fablica do destinat\u00e1rio para criptografar a mensagem. A mensagem criptografada s\u00f3 pode ser descriptografada pelo destinat\u00e1rio, que \u00e9 o \u00fanico detentor da chave privada correspondente.</p> <p>Assinatura Digital: Al\u00e9m da criptografia, o PGP permite que os usu\u00e1rios assinem digitalmente suas mensagens. A assinatura digital \u00e9 criada usando a chave privada do remetente e garante a autenticidade e integridade da mensagem. O destinat\u00e1rio pode verificar a assinatura usando a chave p\u00fablica do remetente para garantir que a mensagem n\u00e3o foi adulterada durante a transmiss\u00e3o.</p> <p>Servidor de Chaves (Chaveiro): Para facilitar o compartilhamento seguro de chaves p\u00fablicas, existe um servi\u00e7o chamado servidor de chaves ou chaveiro. Nesse servidor, os usu\u00e1rios podem publicar suas chaves p\u00fablicas para que outras pessoas possam encontr\u00e1-las e us\u00e1-las para criptografar mensagens. O servidor de chaves tamb\u00e9m permite a busca de chaves p\u00fablicas de outros usu\u00e1rios.</p> <p>Confian\u00e7a em Chaves: O PGP tamb\u00e9m permite que os usu\u00e1rios estabele\u00e7am n\u00edveis de confian\u00e7a nas chaves p\u00fablicas de outras pessoas. Ao encontrar a chave p\u00fablica de algu\u00e9m em um servidor de chaves, o usu\u00e1rio pode validar a autenticidade dessa chave e atribuir-lhe um n\u00edvel de confian\u00e7a. Isso \u00e9 \u00fatil para evitar ataques de homens do meio, onde uma chave falsa \u00e9 apresentada como sendo de outra pessoa.</p>"},{"location":"intranet/","title":"Intranet","text":"<p>O objetivo desta atividade \u00e9 construir uma intranet com os principais servi\u00e7os de uma intranet TCP/IP. Neste caso, teremos que configurar os servi\u00e7os b\u00e1sicos DNS, SMTP + Cliente de e-mail e WWW e demonstrar conhecimento sobre as funcionalidades e sobre a teoria envolvida na concep\u00e7\u00e3o desses protocolos.</p>"}]}